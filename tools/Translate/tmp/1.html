/*
 * Copyright© 2024 Heratino &amp; Nelofus. All rights reserved.
 * author: Heratino &amp; Nelofus
 * Problem: 
 * Tag: 
 * Memory Limit: 
 * Time Limit: 
 * Source: 
 */

// Narcissus &amp; どうか安寧な記憶を

#include &lt;bits/stdc++.h&gt;
using i64 = long long;

constexpr int N = 5e5 + 10;
struct operators {
	int l, r, x, y;
	int type;
	int id;
} qry[N];
int n, m;
int dfn[N], low[N], dfc, sn;
int number[N];
bool instk[N];
int stk[N], tt;
std::vector&lt;int&gt; scc[N];
std::vector&lt;operators&gt; edg[N];
std::basic_string&lt;int&gt; G[N];

void dfs(int u) {
	dfn[u] = low[u] = ++dfc;
	stk[++tt] = u;
	instk[u] = true;
	for (const int &amp;v : G[u]) {
		if (!dfn[v]) {
			dfs(v);
			low[u] = std::min(low[u], low[v]);
		} else if (instk[v]) {
			low[u] = std::min(low[u], dfn[v]);
		}
	}
	if (dfn[u] == low[u]) {
		sn++;
		while (stk[tt] != u) {
			instk[stk[tt]] = false;
			number[stk[tt]] = sn;
			scc[sn].push_back(stk[tt--]);
		}
		instk[stk[tt]] = false;
		number[stk[tt]] = sn;
		scc[sn].push_back(stk[tt--]);
	}
}

void tarjan() {
	for (int i = 1; i &lt;= n; i++)
		if (!dfn[i])
			dfs(i);
}

/*
 * 答案序列
 * 缩点后出度
 * 强连通分量是否有关键点
 * 询问是否已经被加入答案序列
 * 在 bfs 中的 vis
 */
int ans[N];
int otd[N];
int has[N];
int ard[N];
int vis[N];
std::vector&lt;std::pair&lt;int, int&gt;&gt; G2[N];

int tot;
operators qans[N];
void clear(int n, int m) {
	for (int i = 1; i &lt;= n; i++)	G[i].clear(), G2[i].clear();
	for (int i = 1; i &lt;= sn; i++)	scc[i].clear();
	memset(dfn + 1, 0, n * sizeof(int));
	memset(low + 1, 0, n * sizeof(int));
	memset(ans + 1, 0, n * sizeof(int));
	memset(otd + 1, 0, n * sizeof(int));
	memset(has + 1, 0, n * sizeof(int));
	memset(ard + 1, 0, m * sizeof(int));
	memset(vis + 1, 0, n * sizeof(int));
	dfc = 0, sn = 0, tot = 0;
}

inline void add(int u, int v) {G[u] += v;}

void bfs() {
	for (int u = 1; u &lt;= n; u++)
		for (const int &amp;v : G[u]) {
			if (number[u] != number[v]) {
				otd[number[u]]++;
			}
		}

	std::queue&lt;int&gt; q;
	for (int i = 1; i &lt;= m; i++) {
		auto &amp;[l, r, x, y, type, id] = qry[i];
		if (x == 1 &amp;&amp; y == 2)
			G2[l].emplace_back(r, id);
		if (x == 2 &amp;&amp; y == 1)
			G2[r].emplace_back(l, id);
		if (x == 2 &amp;&amp; y == 2) {
			q.push(l);
			q.push(r);
			qans[++tot] = qry[i];
			has[number[l]] = 1;
			has[number[r]] = 1;
			ard[id] = 1;
		}
	}
	for (int i = 1; i &lt;= sn; i++)
		if (otd[i] == 0 &amp;&amp; !has[i]) {
			q.push(scc[i][0]);
			has[i] = 1;
		}
	while (!q.empty()) {
		int u = q.front();
		q.pop();
		if (vis[u])
			continue;
		vis[u] = 1;
		for (const auto &amp;[v, qryid] : G2[u]) {
			if (!ard[qryid]) {
				ard[qryid] = 1, q.push(v);
				qans[++tot] = qry[qryid];
			}
		}
	}
	for (int i = 1; i &lt;= m; i++) {
		auto &amp;[l, r, x, y, type, id] = qry[i];
		if (x == 1 &amp;&amp; y == 1)
			qans[++tot] = qry[i];
	}
}

void solve() {
	std::cin &gt;&gt; n &gt;&gt; m;
	clear(n, m);
	for (int i = 1; i &lt;= m; i++) {
		auto &amp;[l, r, x, y, type, id] = qry[i];
		std::cin &gt;&gt; l &gt;&gt; x &gt;&gt; r &gt;&gt; y;
		if (x == 1 &amp;&amp; y == 1)
			type = 0;
		else if (x == 2 &amp;&amp; y == 2)
			type = 2;
		else
			type = 1;
		id = i;
	}

	for (int i = 1; i &lt;= m; i++) {
		auto &amp;[l, r, x, y, type, id] = qry[i];
		if (x == 1 &amp;&amp; y == 2)
			add(r, l);
		if (x == 2 &amp;&amp; y == 1)
			add(l, r);
	}

	tarjan();
	bfs();

	for (int i = 1; i &lt;= m; i++) {
		auto &amp;[l, r, x, y, type, id] = qans[i];
		if (ans[l] == 0)
			ans[l] = x;
		if (ans[r] == 0)
			ans[r] = y;
	}
	int res = 0;
	for (int i = 1; i &lt;= n; i++)
		res += ans[i];
	std::cout &lt;&lt; res &lt;&lt; &#x27;\n&#x27;;
	// 正序输出
	for (int i = m; i &gt;= 1; i--)
		std::cout &lt;&lt; qans[i].id &lt;&lt; &quot; \n&quot;[i == 1];
}

/* 无法忘却的记忆与苍蓝之梦 */
int main() {
#ifdef HeratinoNelofus
	freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin);
#endif
	std::ios::sync_with_stdio(false);
	std::cin.tie(nullptr);

	int T;
	std::cin &gt;&gt; T;
	while (T--) {
		solve();
	}
	return 0;
}
