<!DOCTYPE html>
<html lang="zh-cn">
	<head>
		<meta charset="utf-8">
		<link type="text/css" rel="stylesheet" href="../additional_files/css/bootstrap.min.css">
		<link type="text/css" rel="stylesheet" href="../additional_files/css/sh_typical.min.css">
		<title>[lydsy4731][uoj267][清华集训2016]魔法小程序</title>
		<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$', '$']], displayMath: [['$$', '$$']]}});</script>
		<script src="../additional_files/js/sh_main.min.js"></script>
		<script src="../additional_files/MathJax-master/MathJax.js?config=TeX-MML-AM_CHTML"></script>
	</head>
	<body>
		<h3>题目描述</h3>
		<p>有这样一段魔法的程序：(其中所有的数组下标从 $0$ 开始，所有的除法的结果为整数，且向 $0$ 取整)</p>
		<pre class="sh_sourceCode"><code><span class="sh_keyword">定义数组</span> a<span class="sh_symbol">[],</span> b<span class="sh_symbol">[],</span> c<span class="sh_symbol">[]</span>
<span class="sh_keyword">定义函数</span> <span class="sh_function">魔法</span><span class="sh_symbol">(</span>x<span class="sh_symbol">,</span> y<span class="sh_symbol">,</span> z<span class="sh_symbol">):</span>
<span class="sh_cbracket">{</span>
	<span class="sh_keyword">如果</span> a<span class="sh_symbol">[]</span> 的长度 <span class="sh_symbol">==</span> z<span class="sh_symbol">:</span>
		<span class="sh_keyword">返回</span> x <span class="sh_symbol">&gt;=</span> y
	<span class="sh_keyword">如果</span> x <span class="sh_symbol">%</span> a<span class="sh_symbol">[</span>z<span class="sh_symbol">]</span> <span class="sh_symbol">&lt;</span> y <span class="sh_symbol">%</span> a<span class="sh_symbol">[</span>z<span class="sh_symbol">]:</span>
		<span class="sh_keyword">返回</span> <span class="sh_keyword">假</span>
	<span class="sh_keyword">返回</span> <span class="sh_function">魔法</span><span class="sh_symbol">(</span>x <span class="sh_symbol">/</span> a<span class="sh_symbol">[</span>z<span class="sh_symbol">]</span>, y <span class="sh_symbol">/</span> a<span class="sh_symbol">[</span>z<span class="sh_symbol">]</span>, z <span class="sh_symbol">+</span> <span class="sh_number">1</span><span class="sh_symbol">)</span>
<span class="sh_cbracket">}</span>
<span class="sh_keyword">定义函数</span> <span class="sh_function">主程序</span><span class="sh_symbol">():</span>
<span class="sh_cbracket">{</span>
	读入 a<span class="sh_symbol">[],</span> b<span class="sh_symbol">[]</span>
	<span class="sh_keyword">令</span> c<span class="sh_symbol">[]</span> 的长度与 b<span class="sh_symbol">[]</span> 的长度相同，且 c<span class="sh_symbol">[]</span> 的每个元素均为 <span class="sh_number">0</span>
	<span class="sh_keyword">令</span> 变量 i 从 <span class="sh_number">0</span> 循环至 b<span class="sh_symbol">[]</span> 的长度 <span class="sh_symbol">-</span> <span class="sh_number">1</span><span class="sh_symbol">:</span>
		<span class="sh_keyword">令</span> 变量 j 从 <span class="sh_number">0</span> 循环至 i<span class="sh_symbol">:</span>
			<span class="sh_keyword">如果</span> <span class="sh_function">魔法</span><span class="sh_symbol">(</span>i<span class="sh_symbol">,</span> j<span class="sh_symbol">,</span> <span class="sh_number">0</span><span class="sh_symbol">):</span>
				c<span class="sh_symbol">[</span>i<span class="sh_symbol">]</span> <span class="sh_symbol">+=</span> b<span class="sh_symbol">[</span>j<span class="sh_symbol">]</span>
	输出 a<span class="sh_symbol">[],</span> c<span class="sh_symbol">[]</span>
<span class="sh_cbracket">}</span>
</code></pre>
		<p>这个程序目前十分低效 (显然时间复杂度至少是平方量级的)，无法快速完成百万级别的计算，但我们现在的任务不仅是优化它。</p>
		<p>现在我们给出这段程序的<strong>输出</strong>，你需要完成一个 "非确定机" 的工作，给出一个可能的输入。</p>
		<p><strong>请注意本题的空间限制。</strong></p>

		<h3>输入格式</h3>
		<p>第一行输入 $a$ 的长度。第二行输入一些空格隔开的<strong>正整数</strong>，依次表示 $a$ 的每一项。</p>
		<p>第三行输入 $c$ 的长度。第四行输入一些空格隔开的<strong>整数</strong>，依次表示 $c$ 的每一项。</p>
		<p>每一行相邻的两个数，恰好用一个空格隔开。</p>
		<p>$a$ 的长度不会超过 $10^4$。$a$ 的每一个元素不会超过 $10^9$。</p>
		<p>$c$ 的长度不会超过 $10^6$。对 $c$ 的元素的范围没有直接的保证，但是保证存在一个解 $b$，使得 $b$ 的每一个元素的绝对值都不超过 $10^9$。</p>
		<p>$a$ 和 $c$ 都至少拥有一个元素。</p>

		<h3>输出格式</h3>
		<p>第一行输出 $a$ 的长度。第二行输入一些空格隔开的正整数，依次表示 $a$ 的每一项。</p>
		<p>第三行输出 $b$ 的长度。第四行输入一些空格隔开的整数，依次表示 $b$ 的每一项。</p>
		<p>每一行相邻的两个数，恰好用一个空格隔开。</p>
		<p>你必须保证你输出的 $b$ 的每一个元素的绝对值都不超过 $10^9$。保证存在一个可行的解满足这个条件。如果有多个可行的解，你可以输出任意一个。</p>

		<h3>题解</h3>
		<p>分析上面这段代码，可以发现<em>魔法</em>这个过程对 $x, y$ 做了一个<em>变进制转化</em>的过程，其中 $a_i$ 为第 $i$ 位的大小。</p>
		<p>$x \bmod a_z &lt; y \bmod a_z$ 的意思是说，在它们的变进制形式中，$x$ 的某一位小于 $y$ 的某一位。在这种情况下，<code>魔法(x, y, z)</code> 将直接返回 <code>假</code>。</p>
		<p>于是 <code>魔法(x, y, z)</code> 为 <code>真</code> 的充要条件是，在 $x$ 和 $y$ 的变进制形式中，$x$ 的每一位都不小于 $y$ 的对应位。</p>
		<p>然后对满足这种条件的有序对 $(x, y)$，令 $c_x \gets c_x + b_y$。</p>
		<p>这是什么意思呢？如果我们把每一位的大小 $i$ 看作<strong>数组某一维的长度</strong>，于是 $x, y$ 可以看做一个多维数组的下标。而 $c_x \gets c_x + b_y$ 的过程——就相当于一次<strong>多维前缀和</strong>的过程。</p>
		<p>由于 $a$ 数组最后在输出时是给定的，以你这个 "非确定机" 工作的实质却是确定的——就是对 $c$ 数组作<em>多维前缀和</em>的逆运算——<strong>多维差分</strong>。</p>
		<p>具体实现的时候，当然不能暴力实现啦，可以使用<strong>每一维依次做差分</strong>的方法来完成 (其实前缀和也能这么玩，参见 Dirichlet 前缀和)。</p>
		<p>注意把长度为 $1$ 的维度压缩掉，这样至多有 $O \left( \log |a| \right)$ 维，每维时间复杂度为 $O \left( |c| \right)$。故总时间复杂度为 $O \left( |c| \log |a| \right)$。</p>

		<h3>代码</h3>

		<div class="panel-body"><pre class="sh_sourceCode"><code class="sh_cpp">#include &lt;bits/stdc++.h&gt;
#define N 10010
#define M 1000010

int A, C;
int a[N], c[M];
long long pro;

int main() {
	int i, j = 0;
	for (scanf("%d", &amp;A), i = 0; i &lt; A; ++i) scanf("%d", a + i);
	for (scanf("%d", &amp;C), i = 0; i &lt; C; ++i) scanf("%d", c + i);
	printf("%d\n", A);
	for (i = 0; i &lt; A; ++i) printf("%d%c", a[i], i == A - 1 ? 10 : 32);
	printf("%d\n", C);
	for (i = 0; i &lt; A; ++i) if (a[i] != 1) a[j++] = a[i]; a[j++] = C; A = j;
	for (i = 0, pro = 1; pro &lt; C; pro *= a[i++])
		for (j = C - 1; j &gt;= 0; --j)
			if (j / pro % a[i]) c[j] -= c[j - pro];
	for (i = 0; i &lt; C; ++i) printf("%d%c", c[i], i == C - 1 ? 10 : 32);
	return 0;
}
</code><script>syntax_highlight()</script>
</pre></div>

		<h3>坑</h3>
		<p><strong>坑1：</strong>注意边界情形，可以在 $a$ 的后面添加一个比较大 (比如等于 $|c|$) 的项。</p>
		<p><strong>坑2：</strong>由于 lydsy 上数据比较毒瘤，必须写 IO 优化还能过 (而且还卡内存，需要使用多次读入的技巧)。</p>
	</body>
</html>
