<!doctype html>
<html lang="zh-cn">
  <head>
    <meta charset="utf-8" />
    <link
      type="text/css"
      rel="stylesheet"
      href="../additional_files/css/bootstrap.min.css"
    />
    <link
      type="text/css"
      rel="stylesheet"
      href="../additional_files/css/sh_typical.min.css"
    />
    <title>lg2178,loj2133,uoj131</title>
    <script src="../additional_files/js/sh_main.min.js"></script>
    <script src="../additional_files/MathJax-master/MathJax.js?config=TeX-MML-AM_CHTML"></script>
  </head>
  <body>
    <h3 id="题目描述">题目描述</h3>
    <p>
      一年一度的“幻影阁夏日品酒大会”隆重开幕了。大会包含品尝和趣味挑战
      两个环节，分别向优胜者颁发“首席品酒家”和“首席猎手”两个奖项，吸引了众多品酒师参加。
    </p>
    <p>
      在大会的晚餐上，调酒师 Rainbow 调制了
      <span class="math inline">\(n\)</span> 杯鸡尾酒。这
      <span class="math inline">\(n\)</span> 杯鸡尾酒排成一行，其中第
      <span class="math inline">\(n\)</span> 杯酒 (<span class="math inline"
        >\(1 ≤ i ≤ n\)</span
      >) 被贴上了一个标签
      <span class="math inline">\(s_i\)</span> ，每个标签都是
      <span class="math inline">\(26\)</span> 个小写 英文字母之一。设
      <span class="math inline">\(str(l, r)\)</span> 表示第
      <span class="math inline">\(l\)</span> 杯酒到第
      <span class="math inline">\(r\)</span> 杯酒的
      <span class="math inline">\(r - l + 1\)</span>
      个标签顺次连接构成的字符串。若
      <span class="math inline">\(str(p, p_0) = str(q, q_0)\)</span>，其中
      <span class="math inline">\(1 ≤ p ≤ p_0 ≤ n\)</span>,
      <span class="math inline">\(1 ≤ q ≤ q_0 ≤ n\)</span>,
      <span class="math inline">\(p ≠ q\)</span>，<span class="math inline"
        >\(p_0-p+1 = q_0 - q + 1 = r\)</span
      >
      ，则称第 <span class="math inline">\(p\)</span> 杯酒与第
      <span class="math inline">\(q\)</span> 杯酒是“
      <span class="math inline">\(r\)</span> 相似” 的。当然两杯“
      <span class="math inline">\(r\)</span> 相似”(<span class="math inline"
        >\(r &gt; 1\)</span
      >)的酒同时也是“ <span class="math inline">\(1\)</span> 相似”、“
      <span class="math inline">\(2\)</span> 相似”、……、“
      <span class="math inline">\((r - 1)\)</span> 相似”的。特别地，对于任意的
      <span class="math inline">\(1 ≤ p ,q ≤ n,p ≠ q\)</span>，第
      <span class="math inline">\(p\)</span> 杯酒和第
      <span class="math inline">\(q\)</span> 杯酒都 是“
      <span class="math inline">\(0\)</span> 相似”的。
    </p>
    <p>
      在品尝环节上，品酒师 Freda
      轻松地评定了每一杯酒的美味度，凭借其专业的水准和经验成功夺取了“首席品酒家”的称号，其中第
      <span class="math inline">\(i\)</span> 杯酒 (<span class="math inline"
        >\(1 ≤ i ≤ n\)</span
      >) 的 美味度为 <span class="math inline">\(a_i\)</span> 。现在 Rainbow
      公布了挑战环节的问题：本次大会调制的鸡尾酒有一个特点，如果把第
      <span class="math inline">\(p\)</span> 杯酒与第
      <span class="math inline">\(q\)</span> 杯酒调兑在一起，将得到一杯美味度为
      <span class="math inline">\(a_p\times a_q\)</span> 的
      酒。现在请各位品酒师分别对于
      <span class="math inline">\(r = 0,1,2,⋯,n-1\)</span>
      ，统计出有多少种方法可以 选出 <span class="math inline">\(2\)</span> 杯“
      <span class="math inline">\(r\)</span> 相似”的酒，并回答选择
      <span class="math inline">\(2\)</span> 杯“<span class="math inline"
        >\(r\)</span
      >
      相似”的酒调兑可以得到的美味度的最大值。
    </p>
    <h3 id="输入格式">输入格式</h3>
    <p>
      第 <span class="math inline">\(1\)</span> 行包含
      <span class="math inline">\(1\)</span> 个正整数
      <span class="math inline">\(n\)</span> ，表示鸡尾酒的杯数。
    </p>
    <p>
      第 <span class="math inline">\(2\)</span> 行包含一个长度为
      <span class="math inline">\(n\)</span> 的字符串
      <span class="math inline">\(S\)</span>，其中第
      <span class="math inline">\(i\)</span> 个字符表示第
      <span class="math inline">\(i\)</span> 杯酒的标签。
    </p>
    <p>
      第 <span class="math inline">\(3\)</span> 行包含
      <span class="math inline">\(n\)</span>
      个整数，相邻整数之间用单个空格隔开，其中第
      <span class="math inline">\(i\)</span> 个整数表示第
      <span class="math inline">\(i\)</span> 杯酒的美味度
      <span class="math inline">\(a_i\)</span> 。
    </p>
    <h3 id="输出格式">输出格式</h3>
    <p>包括 <span class="math inline">\(n\)</span> 行。</p>
    <p>
      第 <span class="math inline">\(i\)</span> 行输出
      <span class="math inline">\(2\)</span> 个整数，中间用单个空格隔开。第
      <span class="math inline">\(1\)</span> 个整 数表示选出两杯“
      <span class="math inline">\((i - 1)\)</span> 相似”的酒的方案数，第 2
      个整数表示选出两杯 “
      <span class="math inline">\((i - 1)\)</span>
      相似”的酒调兑可以得到的最大美味度。若不存在两杯“
      <span class="math inline">\((i - 1)\)</span> 相似” 的酒，这两个数均为
      <span class="math inline">\(0\)</span> 。
    </p>
    <h3 id="数据范围">数据范围</h3>
    <table>
      <colgroup>
        <col style="width: 25%" />
        <col style="width: 25%" />
        <col style="width: 25%" />
        <col style="width: 25%" />
      </colgroup>
      <thead>
        <tr class="header">
          <th style="text-align: center">Case #</th>
          <th style="text-align: center">
            <span class="math inline">\(n\)</span> 的规模
          </th>
          <th style="text-align: center">
            <span class="math inline">\(a_i\)</span> 的规模
          </th>
          <th style="text-align: center">备注</th>
        </tr>
      </thead>
      <tbody>
        <tr class="odd">
          <td style="text-align: center">1</td>
          <td style="text-align: center">
            <span class="math inline">\(n = 100\)</span>
          </td>
          <td style="text-align: center">
            <span class="math inline">\(\lvert a_i \rvert \leq 10000\)</span>
          </td>
          <td style="text-align: center">-</td>
        </tr>
        <tr class="even">
          <td style="text-align: center">2</td>
          <td style="text-align: center">
            <span class="math inline">\(n = 200\)</span>
          </td>
          <td style="text-align: center">
            <span class="math inline">\(\lvert a_i \rvert \leq 10000\)</span>
          </td>
          <td style="text-align: center">-</td>
        </tr>
        <tr class="odd">
          <td style="text-align: center">3</td>
          <td style="text-align: center">
            <span class="math inline">\(n = 500\)</span>
          </td>
          <td style="text-align: center">
            <span class="math inline">\(\lvert a_i \rvert \leq 10000\)</span>
          </td>
          <td style="text-align: center">-</td>
        </tr>
        <tr class="even">
          <td style="text-align: center">4</td>
          <td style="text-align: center">
            <span class="math inline">\(n = 750\)</span>
          </td>
          <td style="text-align: center">
            <span class="math inline">\(\lvert a_i \rvert \leq 10000\)</span>
          </td>
          <td style="text-align: center">-</td>
        </tr>
        <tr class="odd">
          <td style="text-align: center">5</td>
          <td style="text-align: center">
            <span class="math inline">\(n = 1000\)</span>
          </td>
          <td style="text-align: center">
            <span class="math inline"
              >\(\lvert a<td style="text-align: center;"><span class="math inline">\(\lvert a_i
\rvert \leq 1000000000\)</span></td>
<td style="text-align: center;">不存在「<span
class="math inline">\(10\)</span> 相似」的酒</td>
</tr>
<tr class="even">
<td style="text-align: center;">10</td>
<td style="text-align: center;"><span class="math inline">\(n =
99991\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\lvert a_i
\rvert \leq 1000000000\)</span></td>
<td style="text-align: center;">不存在「<span
class="math inline">\(10\)</span> 相似」的酒</td>
</tr>
<tr class="odd">
<td style="text-align: center;">11</td>
<td style="text-align: center;"><span class="math inline">\(n =
100000\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\lvert a_i
\rvert \leq 1000000\)</span></td>
<td style="text-align: center;">所有 <span
class="math inline">\(a_i\)</span> 的值都相等</td>
</tr>
<tr class="even">
<td style="text-align: center;">12</td>
<td style="text-align: center;"><span class="math inline">\(n =
200000\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\lvert a_i
\rvert \leq 1000000\)</span></td>
<td style="text-align: center;">所有 <span
class="math inline">\(a_i\)</span> 的值都相等</td>
</tr>
<tr class="odd">
<td style="text-align: center;">13</td>
<td style="text-align: center;"><span class="math inline">\(n =
300000\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\lvert a_i
\rvert \leq 1000000\)</span></td>
<td style="text-align: center;">所有 <span
class="math inline">\(a_i\)</span> 的值都相等</td>
</tr>
<tr class="even">
<td style="text-align: center;">14</td>
<td style="text-align: center;"><span class="math inline">\(n =
300000\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\lvert a_i
\rvert \leq 1000000\)</span></td>
<td style="text-align: center;">所有 <span
class="math inline">\(a_i\)</span> 的值都相等</td>
</tr>
<tr class="odd">
<td style="text-align: center;">15</td>
<td style="text-align: center;"><span class="math inline">\(n =
100000\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\lvert a_i
\rvert \leq 1000000000\)</span></td>
<td style="text-align: center;">-</td>
</tr>
<tr class="even">
<td style="text-align: center;">16</td>
<td style="text-align: center;"><span class="math inline">\(n =
100000\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\lvert a_i
\rvert \leq 1000000000\)</span></td>
<td style="text-align: center;">-</td>
</tr>
<tr class="odd">
<td style="text-align: center;">17</td>
<td style="text-align: center;"><span class="math inline">\(n =
200000\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\lvert a_i
\rvert \leq 1000000000\)</span></td>
<td style="text-align: center;">-</td>
</tr>
<tr class="even">
<td style="text-align: center;">18</td>
<td style="text-align: center;"><span class="math inline">\(n =
200000\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\lvert a_i
\rvert \leq 1000000000\)</span></td>
<td style="text-align: center;">-</td>
</tr>
<tr class="odd">
<td style="text-align: center;">19</td>
<td style="text-align: center;"><span class="math inline">\(n =
300000\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\lvert a_i
\rvert \leq 1000000000\)</span></td>
<td style="text-align: center;">-</td>
</tr>
<tr class="even">
<td style="text-align: center;">20</td>
<td style="text-align: center;"><span class="math inline">\(n =
300000\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\lvert a_i
\rvert \leq 1000000000\)</span></td>
<td style="text-align: center;">-</td>
</tr>
</tbody>
</table>
<h3 id="题解">题解</h3>
<p>先计算相似度大的答案，再计算相似度小的答案。</p>
<p><span class="math inline">\(p\)</span> 和 <span
class="math inline">\(q\)</span> 的最大相似度是 <span
class="math inline">\(\left|\operatorname{LCP}(\operatorname{Suffix}(s,p),\operatorname{Suffix}(s,q))\right|\)</span>。也就是
<span class="math display">\[
\min_{i=\operatorname{rank}(p)+1}^{\operatorname{rank}(q)}\{\operatorname{height}(i)\}
\]</span> 令 <span class="math inline">\(\operatorname{height}\)</span>
从大到小排序，每次取 <span
class="math inline">\(\operatorname{height}\)</span> 最大的 <span
class="math inline">\(i\)</span>，合并 <span
class="math inline">\(i\)</span> 与 <span
class="math inline">\(\operatorname{SA}(\operatorname{rank}(i)-1)\)</span>
所属的集合。</p>
<p>这样每个集合里两两的 <span
class="math inline">\(\operatorname{LCP}\)</span>
长度都不小于当前值，并查集维护集合合并即可。</p>
<h3 id="代码">代码</h3>
<div class="panel-body"><pre class="sh_sourceCode"><code class="sh_cpp">#include &lt;bits/stdc++.h&gt;
using i64 = long long;

constexpr int N = 3e5 + 10;
int mp[26];

int cnt[N], tmp[N], SA[N], rk[N];
void induce(int n, int m, std::vector&lt;int&gt; &amp;a, std::vector&lt;int&gt; &amp;lms, std::vector&lt;int&gt; &amp;type) {
	auto pushBG = [&amp;](const int &amp;x) {SA[tmp[a[x]]++] = x;};
	auto pushED = [&amp;](const int &amp;x) {SA[tmp[a[x]]--] = x;};
	memset(cnt,  0, (n + 1) * sizeof(int));
	memset(SA , -1, (n + 1) * sizeof(int));

	for (int i = 1; i &lt;= n; i++)	cnt[a[i]]++;
	for (int i = 1; i &lt;= n; i++)	cnt[i] += cnt[i - 1];

	for (int i = 1; i &lt;= n; i++)	tmp[i] = cnt[i];
	for (int i = m; i &gt;= 1; i--)	pushED(lms[i]);

	/* 当前该插入的位置 */
	for (int i = 1; i &lt;= n; i++)	tmp[i] = cnt[i - 1] + 1;
	/* 如果这个位置是 LMS 子串, 加入上一个位置 */
	for (int i = 1; i &lt;= n; i++)
		if (SA[i] &gt; 1 &amp;&amp; type[SA[i] - 1] == 0)
			pushBG(SA[i] - 1);

	for (int i = 1; i &lt;= n; i++)	tmp[i] = cnt[i];
	for (int i = n; i &gt;= 1; i--)
		if (SA[i] &gt; 1 &amp;&amp; type[SA[i] - 1] == 1)
			pushED(SA[i] - 1);
}
void SAIS(int n, std::vector&lt;int&gt; &amp;a) {
	std::vector&lt;int&gt; LMS(n + 2, 0);
	std::vector&lt;int&gt; type(n + 1, -1);
	type[n] = 1;
	for (int i = n - 1; i &gt;= 1; i--)
		if (a[i] == a[i + 1])
			type[i] = type[i + 1];
		else
			type[i] = a[i] &lt; a[i + 1];
	int m = 0;
	for (int i = 1; i &lt;= n; i++)
		if (type[i] == 1 &amp;&amp; type[i - 1] == 0)
			LMS[++m] = i, rk[i] = m;
		else
			rk[i] = -1;
	induce(n, m, a, LMS, type);
	LMS[m + 1] = n;
	int tot = 0;
	std::vector&lt;int&gt; nxt(m + 1, 0);
	for (int i = 1, x, y; i &lt;= n; i++) {
		x = rk[SA[i]];
		if (x == -1)
			continue;
		if (tot == 0 || LMS[y + 1] - LMS[y] != LMS[x + 1] - LMS[x])
			tot++;
		else
			for (int p1 = LMS[x], p2 = LMS[y]; p2 &lt;= LMS[y + 1]; p1++, p2++)
				if (a[p1] != a[p2] || type[p1] != type[p2]) {
					tot++;
					break;
				}
		// 第 x 个 LMS 排名是 tot
		nxt[x] = tot;
		y = x;
	}
	if (tot == m)
		for (int i = 1; i &lt;= m; i++)
			SA[nxt[i]] = i;
	else
		SAIS(m, nxt);
	// 实际上是对离散化后的 LMS 排序, 复原
	// 按从小到大的顺序加入
	for (int i = 1; i &lt;= m; i++)
		nxt[i] = LMS[SA[i]];
	induce(n, m, a, nxt, type);
}

std::vector&lt;int&gt; a;
int ht[N];
void GetSuffixArray(int n, std::string s) {
	for (int i = 1; i &lt;= n; i++)
		mp[s[i] - &#x27;a&#x27;] = 1;
	for (int i = 1; i &lt; 26; i++)
		mp[i] += mp[i - 1];
	a.resize(n + 2, 0);
	for (int i = 1; i &lt;= n; i++)	a[i] = mp[s[i] - &#x27;a&#x27;] + 1;
	a[n + 1] = 1;
	SAIS(n + 1, a);
	
	SA[0] = 0;
	for (int i = 1; i &lt;= n; i++)
		SA[i] = SA[i + 1];
	for (int i = 1; i &lt;= n; i++)
		rk[SA[i]] = i;
	for (int i = 1, k = 0; i &lt;= n; i++) {
		if (k)	k--;
		while (a[i + k] == a[SA[rk[i] - 1] + k])	k++;
		ht[rk[i]] = k;
	}
}

int n;
std::string s;

i64 curans;
int fa[N], siz[N];
int minx[N], maxx[N];
i64 ans1[N], ans2[N];
int cur;

inline int find(int x) {
	return x == fa[x] ? x : fa[x] = find(fa[x]);
}

void merge(int u, int v) {
	u = find(u), v = find(v);
	if (u == v)
		return ;
	if (siz[u] &gt; siz[v])	std::swap(u, v);
	fa[u] = v;
	ans1[cur] += 1ll * siz[u] * siz[v];
	i64 t1 = std::max(1ll * minx[u] * minx[v], 1ll * maxx[u] * maxx[v]);
	i64 t2 = std::max(1ll * minx[u] * maxx[v], 1ll * maxx[u] * minx[v]);
	ans2[cur] = std::max(ans2[cur], std::max(t1, t2));
	minx[v] = std::min(minx[u], minx[v]);
	maxx[v] = std::max(maxx[u], maxx[v]);
	siz[v] += siz[u];
}

int main() {
#ifdef HeratinoNelofus
	freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin);
#endif
	std::ios::sync_with_stdio(false);
	std::cin.tie(nullptr);

	std::cin &gt;&gt; n &gt;&gt; s;
	s = &#x27; &#x27; + s;
	GetSuffixArray(n, s);

	for (int i = 1; i &lt;= n; i++)
		fa[i] = i, siz[i] = 1;

	for (int i = 1; i &lt;= n; i++) {
		std::cin &gt;&gt; minx[i];
		maxx[i] = minx[i];
	}
	std::priority_queue&lt;std::pair&lt;int, int&gt;&gt; q;
	ans2[n] = -2e18;

	// 这里是排名
	for (int i = 2; i &lt;= n; i++)
		q.push({ht[i], i});

	for (cur = n - 1; cur &gt;= 0; cur--) {
		ans1[cur] = ans1[cur + 1], ans2[cur] = ans2[cur + 1];
		while (!q.empty() &amp;&amp; q.top().first == cur) {
			auto [p, c] = q.top();
			q.pop();
			merge(SA[c - 1], SA[c]);
		}
	}
	for (int i = 0; i &lt; n; i++) {
		std::cout &lt;&lt; ans1[i] &lt;&lt; &#x27; &#x27;;
		if (ans2[i] == -(i64)2e18) {
			std::cout &lt;&lt; 0 &lt;&lt; &#x27;\n&#x27;;
		} else {
			std::cout &lt;&lt; ans2[i] &lt;&lt; &#x27;\n&#x27;;
		}
	}
	return 0;
}

</code><script>syntax_highlight()</script>
</pre></div>

</body>
</html>